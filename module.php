<?php
	declare(strict_types=1);
	/**
	 *  +------------------------------------------------------------+
	 *  | apnscp                                                     |
	 *  +------------------------------------------------------------+
	 *  | Copyright (c) Apis Networks                                |
	 *  +------------------------------------------------------------+
	 *  | Licensed under Artistic License 2.0                        |
	 *  +------------------------------------------------------------+
	 *  | Author: Matt Saladna (msaladna@apisnetworks.com)           |
	 *  +------------------------------------------------------------+
	 */

	use Module\Support\Webapps\App\Type\Discourse\Launcher;
	use Module\Support\Webapps\Passenger;
	use Module\Support\Webapps\PathManager;
	use Module\Support\Webapps\Traits\PublicRelocatable;
	use Module\Support\Webapps\VersionFetcher\Github;
	use Opcenter\Net\Port;

	/**
	 * Discourse management
	 *
	 * Forum software
	 *
	 * @package core
	 */
	class Discourse_Module extends \Module\Support\Webapps
	{
		use PublicRelocatable {
			getAppRoot as getAppRootReal;
		}

		// via config/application.rb
		const MINIMUM_INTERPRETERS = [
			'0'           => '2.4.2',
			'2.2.0.beta5' => '2.5.2',
			'2.5.0'       => '2.6.5',
			'2.6.0'       => '2.7.2',
			'3.0.0'       => '3.1.3',
			'3.1.0'       => '3.2.0'
		];

		// via https://github.com/discourse/discourse_docker/blob/master/image/base/Dockerfile#L29
		// "debsource" install
		const NODE_VERSIONS = [
			'0'   => '8',
			'2.4' => '10',
			'2.5' => '14',
			'2.6' => '15',
			'2.8' => '16',
			'3.2' => '18'
		];

		const APP_NAME = 'Discourse';
		const DEFAULT_VERSION_LOCK = 'minor';
		const DISCOURSE_REPO = 'https://github.com/discourse/discourse.git';

		public function __construct()
		{
			parent::__construct();
			$this->exportedFunctions['restart'] = PRIVILEGE_SITE | PRIVILEGE_USER;
		}

		public function plugin_status(string $hostname, string $path = '', string $plugin = null)
		{
			return error('not supported');
		}

		public function uninstall_plugin(string $hostname, string $path, string $plugin, bool $force = false): bool
		{
			return error('not supported');
		}

		public function disable_all_plugins(string $hostname, string $path = ''): bool
		{
			return error('not supported');
		}

		/**
		 * Get next Discourse version
		 *
		 * @param string $version
		 * @param string $maximalbranch
		 * @return null|string
		 */
		public function next_version(string $version, string $maximalbranch = '99999999.99999999.99999999'): ?string
		{
			return parent::next_version($version, $maximalbranch);
		}

		/**
		 * @inheritDoc
		 */
		public function reconfigure(string $hostname, string $path, $param, $value = null): bool
		{
			return parent::reconfigure($hostname, $path, $param, $value); // TODO: Change the autogenerated stub
		}

		/**
		 * @inheritDoc
		 */
		public function reconfigurables(string $hostname, string $path = ''): array
		{
			return parent::reconfigurables($hostname, $path);
		}

		/**
		 * @param string       $hostname
		 * @param string       $path
		 * @param string|array $fields
		 * @return mixed
		 */
		public function get_configuration(string $hostname, string $path, $fields): array
		{
			if (!IS_CLI) {
				return $this->query('discourse_get_configuration', $hostname, $path, $fields);
			}
			$config = $this->getAppRoot($hostname, $path) . '/config/discourse.conf';
			$stat = $this->file_stat($config);

			if (!$stat['can_read']) {
				error("Path %(path)s unreadable", ['path' => $config]);
				return [];
			}

			$map = \Opcenter\Map::read($this->domain_fs_path($config), 'inifile')->section(null);
			$values = [];
			foreach ((array)$fields as $k) {
				$values[$k] = $map->fetch($k);
			}
			if (\count($values) === 1) {
				return array_pop($values);
			}

			return $values;
		}

		/**
		 * Get app root for Discourse
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return null|string
		 */
		protected function getAppRoot(string $hostname, string $path = ''): ?string
		{
			return $this->getAppRootReal($hostname, $path);
		}

		/**
		 * Install Discourse into a pre-existing location
		 *
		 * @TODO disable cgroup OOM killer on 1 GB sites?
		 *
		 * @param string $hostname domain or subdomain to install Laravel
		 * @param string $path     optional path under hostname
		 * @param array  $opts     additional install options
		 * @return bool
		 */
		public function install(string $hostname, string $path = '', array $opts = array()): bool
		{
			if (posix_geteuid() && !IS_CLI) {
				return $this->query('discourse_install', $hostname, $path, $opts);
			}

			if (!$this->pgsql_enabled()) {
				return error('%(what)s must be enabled to install %(app)s', ['what' => 'PostgreSQL', 'app' => static::APP_NAME]);
			}
			if (!SSH_USER_DAEMONS) {
				return error('[ssh] => user_daemons must be set to true in config.ini');
			}
			$available = null;
			if (!$this->hasMemoryAllowance(1536, $available)) {
				return error("Discourse requires at least 1.5 GB memory, `%s' MB provided for account", $available);
			}
			if (!$this->hasStorageAllowance(2048, $available)) {
				return error('Discourse requires ~2 GB storage. Only %.2f MB free.', $available);
			}

			if ($this->getServiceValue('cgroup', 'enabled') && ($limit = $this->getServiceValue('cgroup',
					'proclimit') ?: 100) < 100) {
				return error("Resource limits enforced. proclimit `%d' is below minimum value 100. Change via cgroup,proclimit",
					$limit);
			}

			if (!$this->crontab_permitted()) {
				return error('%(app)s requires %(service)s service to be enabled', [
					'app' => self::APP_NAME, 'service' => 'crontab'
				]);
			}

			if (!$this->crontab_enabled() && !$this->crontab_start()) {
				return error('Failed to enable task scheduling');
			}

			if (!empty($opts['maxmind']) && !preg_match('/^[a-zA-Z0-9_]{4,}$/', $opts['maxmind'])) {
				return error('A MaxMind GeoLite2 key is required.');
			}

			if (!isset($opts['mode'])) {
				$opts['mode'] = 'apache';
			}

			if ($opts['mode'] !== 'standalone' && $opts['mode'] !== 'nginx' && $opts['mode'] !== 'apache') {
				return error("Unknown Discourse mode `%s'", $opts['mode']);
			}

			// assume all Discourse installs will be located in a parent directory
			// once installed, relink the domain/subdomain to $docroot + /public
			// also block installing under a path, because this would require either relocating
			// Discourse outside any document root, e.g. /var/www/<hostname>-<path>-discourse and making
			// a symlink, which fails once the parent document root moves (must use relative symlinks)
			// and clutters up wherever they get located... no sound solution
			if ($path) {
				return error('Discourse may only be installed directly on a subdomain or domain without a child path, e.g. https://discourse.domain.com but not https://domain.com/discourse');
			}

			if (!($docroot = $this->getDocumentRoot($hostname, $path))) {
				return error("failed to normalize path for `%s'", $hostname);
			}

			if (!$this->parseInstallOptions($opts, $hostname, $path)) {
				return false;
			}

			$rubyVersion = \Opcenter\Versioning::satisfy($opts['version'], self::MINIMUM_INTERPRETERS);
			if (!($rubyVersion = $this->validateRuby($rubyVersion, $opts['user'] ?? null))) {
				return false;
			}

			$args['version'] = $opts['version'];
			$db = \Module\Support\Webapps\DatabaseGenerator::pgsql($this->getAuthContext(), $hostname);
			$db->connectionLimit = max($db->connectionLimit, 15);

			if (!$db->create()) {
				return false;
			}

			$context = null;
			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($docroot, $context);
			$oldex = \Error_Reporter::exception_upgrade();
			try {
				$wrapper->git_clone(static::DISCOURSE_REPO, $docroot,
					[
						'recursive' => null,
						'depth'     => 1,
						'branch'    => 'v' . $opts['version']
					]);
				$this->ruby_make_default($rubyVersion, $docroot);
				$bundler = 'bundler:"< 2"';
				if (version_compare($args['version'], '2.3.8', '>=')) {
					$bundler = 'bundler:"~> 2.2"';
					if (version_compare($args['version'], '3.1.0', '<')) {
						$bundler = 'bundler:"<= 2.4.22"';
					}
				}
				$wrapper->ruby_do($rubyVersion, $docroot, 'gem install -E --no-document passenger ' . $bundler);

				$bundleFlags = '--deployment --without test development';

				if (version_compare($args['version'], '2.5.0', '>=')) {
					$wrapper->ruby_do($rubyVersion, $docroot, 'bundle config set deployment true');
					$wrapper->ruby_do($rubyVersion, $docroot, 'bundle config set without "test development"');
					$bundleFlags = '';
				}

				if (version_compare($args['version'], '2.8.10', '>=') && version_compare($rubyVersion, '3.1.3', '<')) {
					$wrapper->ruby_do($rubyVersion, $docroot, 'gem update --system 3.2.28 --no-doc');
				}

				$wrapper->ruby_do('', $docroot, 'bundle install ' . $bundleFlags . ' -j' . max(4, (int)NPROC + 1));
				# renice requires CAP_SYS_NICE, which Discourse doesn't catch
				$wrapper->file_put_file_contents($wrapper->user_get_home() . '/.rbenv-usergems/' . $rubyVersion . '/bin/renice',
					"#!/bin/sh\nexec /bin/true");
				$wrapper->file_chmod($wrapper->user_get_home() . '/.rbenv-usergems/' . $rubyVersion . '/bin/renice', 755);
				$this->applyPatches($wrapper, $docroot, $args['version']);
				$extensions = ['pg_trgm', 'hstore'];
				if (version_compare($args['version'], '3.0', '>=')) {
					$extensions[] = 'unaccent';
				}
				foreach ($extensions as $extension) {
					$this->pgsql_add_extension($db->database, $extension);
				}
				if (!$wrapper->crontab_user_permitted($opts['user'] ?? $this->username)) {
					if (!$this->crontab_permit_user($opts['user'] ?? $this->username)) {
						return error("failed to enable task scheduling for `%s'", $opts['user'] ?? $this->username);
					}
					warn("Task scheduling enabled for user `%s'", $opts['user'] ?? $this->username);
				}
			} catch (\apnscpException $e) {
				if (array_get($opts, 'hold')) {
					return false;
				}
				info('removing temporary files');
				$this->file_delete($docroot, true);
				$db->rollback();
				return error('failed to install Discourse %s: %s', $args['version'], $e->getMessage());
			} finally {
				\Error_Reporter::exception_upgrade($oldex);
			}

			$opts['url'] = rtrim($hostname . '/' . $path, '/');

			if (null === ($docroot = $this->remapPublic($hostname, $path))) {
				// it's more reasonable to fail at this stage, but let's try to complete
				return error("Failed to remap Discourse to public/, manually remap from `%s' - Discourse setup is incomplete!",
					$docroot);
			}

			$docroot = $this->getDocumentRoot($hostname, $path);
			$approot = $this->getAppRoot($hostname, $path);

			$config = $approot . '/config/discourse.conf';
			$wrapper->file_copy($approot . '/config/discourse_defaults.conf', $config);

			$configurables = [
				'db_name'            => $db->database,
				'db_username'        => $db->username,
				'db_password'        => $db->password,
				'hostname'           => $hostname,
				'db_host'            => $db->hostname,
				'developer_emails'   => $opts['email'],
				'load_mini_profiler' => false
			];

			if (!empty($opts['maxmind'])) {
				$configurables['maxmind_license_key'] = $opts['maxmind'];
			}


			$this->set_configuration($hostname, $path, $configurables);

			if (version_compare($args['version'], '3.0.0', '>=')) {
				$this->createMailUser($hostname, $path);
			}

			$redispass = \Opcenter\Auth\Password::generate(32);
			if ($wrapper->redis_exists($this->domain)) {
				warn("Existing Redis profile named `%s' found - removing", $this->domain);
				$wrapper->redis_delete($this->domain);
			}
			$wrapper->redis_create($this->domain, ['requirepass' => $redispass]);
			$redisconfig = $wrapper->redis_config($this->domain);

			$vars = [
				'redis_port'     => $redisconfig['port'],
				'redis_host'     => '127.0.0.1',
				'redis_password' => $redisconfig['requirepass'],
				'db_pool'        => 7
			];
			$this->set_configuration($hostname, $path, $vars);

			/**
			 * Sidekiq + DB migration + asset generation
			 */
			$exold = \Error_Reporter::exception_upgrade();
			try {
				$nodeVersion = $this->validateNode((string)$opts['version'], $wrapper);
				$this->node_make_default($nodeVersion, $approot);
				$this->assetsCompile($hostname, $path, 'production');
				$this->migrate($approot);
				if (version_compare($opts['version'], '2.4.0', '<')) {
					$this->launchSidekiq($approot, 'production');

					$passenger = Passenger::instantiateContexted($context, [$approot, 'ruby']);
					$passenger->createLayout();
					$passenger->setEngine('standalone');
					// avoid excessive mutex locking in Passenger
					$passenger->setProcessConcurrency(0);
					$passenger->setMaxPoolSize(3);
					$passenger->setMinInstances(3);
					$passenger->setEnvironment([
						'RUBY_GLOBAL_METHOD_CACHE_SIZE'       => 131072,
						'LD_PRELOAD'                          => '/usr/lib64/libjemalloc.so.1',
						'RUBY_GC_HEAP_GROWTH_MAX_SLOTS'       => 40000,
						'RUBY_GC_HEAP_INIT_SLOTS'             => 400000,
						'RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR' => 1.5
					]);
					$this->file_put_file_contents($approot . '/Passengerfile.json',
						$passenger->getExecutableConfiguration());
					$passenger->start();
				} else {
					$handler = Launcher::instantiateContexted($context,
						[$approot]);
					$handler->create(Port::firstFree($this->getAuthContext()));
				}
			} catch (\apnscpException $e) {
				dlog($e->getTraceAsString());

				return error('Error encountered during housekeeping. Discourse may be incomplete: %s',
					$e->getMessage());
			} finally {
				\Error_Reporter::exception_upgrade($exold);
			}

			if (version_compare($opts['version'], '2.4.0', '>=')) {
				$launcher = Launcher::instantiateContexted($context, [$approot]);
				$launcher->start();
				$command = $launcher->getCommand();
				$rules = 'RewriteEngine On' . "\n" .
					'RewriteCond %{REQUEST_FILENAME} !-f' . "\n" .
					'RewriteRule ^(.*)$ http://localhost:' . $launcher->getPort() . '/$1 [P,L,QSA]' . "\n";
			} else {
				$command = $passenger->getExecutable();
				$this->pman_run($command);
				$rules = $passenger->getDirectives();
			}
			if (!isset($passenger) || $passenger->getEngine() !== 'apache') {
				$args = [
					'@reboot',
					null,
					null,
					null,
					null,
					$command
				];
				if (!($wrapper->crontab_exists(...$args) || $wrapper->crontab_add_job(...$args))) {
					warn('Failed to create job to start Discourse on boot. Command: %s', $command);
				}
			}


			if (!empty($opts['ssl'])) {
				$rules = 'RequestHeader set X-Forwarded-Proto expr=%{REQUEST_SCHEME}' . "\n" .
					$rules;
			}
			if (!$this->file_put_file_contents($approot . '/public/.htaccess',
				'# Enable caching' . "\n" .
				'UnsetEnv no-cache' . "\n" .
				// prevents page not found on vanilla installs
				// defaults to index.html otherwise
				'DirectoryIndex disabled' . "\n" .
				$rules
			)) {
				return error('failed to create .htaccess control - Discourse is not properly setup');
			}
			$this->notifyInstalled($hostname, $path, $opts);

			return info('%(app)s installed - confirmation email with login info sent to %(email)s',
				['app' => static::APP_NAME, 'email' => $opts['email']]);
		}

		/**
		 * Create unprivileged mail relay user
		 *
		 * Required for v3.0.0, SMTP provider changed to net-smtp
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return void
		 */
		private function createMailUser(string $hostname, string $path = ''): void
		{
			if (version_compare($this->get_version($hostname, $path), '3.0.0', '<')) {
				return;
			}
			if (!$this->email_enabled()) {
				warn("Mail disabled on account. Manual SMTP configuration required to config/discourse.conf");
				return;
			}

			$cfg = $this->get_configuration($hostname, $path, ['smtp_user_name', 'smtp_address']);
			if (array_get($cfg, 'smtp_address') && $cfg['smtp_user_name']) {
				return;
			}

			$user = 'discourse-' . \Opcenter\Auth\Password::generate(8, 'a-z');
			$password = \Opcenter\Auth\Password::generate(16);
			if (!$this->user_add($user, $password, 'Discourse email user - ' . $hostname, 0, [
				'smtp'  => true,
				'cp'    => false,
				'ssh'   => false,
				'ftp'   => false,
				'imap'  => false
			]))
			{
				warn("Failed to create SMTP user for Discourse. Manual configuration of SMTP required");
				return;
			}
			$this->set_configuration($hostname, $path, [
				'smtp_user_name' => "$user@$hostname",
				'smtp_password'  => $password,
				'smtp_address'   => 'localhost',
				'smtp_port'      => 587,
				'smtp_enable_start_tls' => 'false',
			]);


		}

		private function deleteMailUser(string $hostname, string $path = ''): void
		{
			$cfg = $this->get_configuration($hostname, $path, ['smtp_user_name', 'smtp_address']);
			if (array_get($cfg, 'smtp_address') !== 'localhost' || !str_contains($cfg['smtp_user_name'], "@$hostname")) {
				return;
			}

			$user = strtok($cfg['smtp_user_name'], '@');
			if (!($pwd = $this->user_getpwnam($user)) || !str_starts_with($pwd['gecos'], "Discourse email user")) {
				return;
			}
			$this->user_delete($user, true);
		}

		/**
		 * Additional version checks
		 *
		 * @param array $options
		 * @return bool
		 */
		protected function checkVersion(array &$options): bool
		{
			if (!parent::checkVersion($options)) {
				return false;
			}
			$version = array_get($options, 'version');

			// Requires Redis 4.0 by Sidekiq 6 compat
			$redisVersion = $this->redis_version();
			foreach(['2.4.0' => '4.0.0', '3.0.0' => '6.2.0'] as $discourseVersion => $redisReq) {
				if (version_compare($version, $discourseVersion, '<')) {
					return true;
				}

				if (version_compare($redisVersion, $redisReq, '<')) {
					return error('%(app)s %(version)s+ requires %(pkgname)s %(pkgver)s+. ' .
						'%(pkgname)s %(pkginstver)s installed in FST', [
						'app' => self::APP_NAME,
						'version' => $version,
						'pkgname' => 'Redis',
						'pkgver' => $redisReq,
						'pkginstver' => $redisVersion
					]);
				}
			}

			return true;
		}

		/**
		 * Verify Node LTS is installed
		 *
		 * @param string|null $version optional version to compare against
		 * @param string|null $user
		 * @return string|null
		 */
		protected function validateRuby(string $version = 'lts', string $user = null): ?string
		{
			debug("Validating Ruby %s installed", $version);
			if ($user) {
				$afi = \apnscpFunctionInterceptor::factory(Auth::context($user, $this->site));
			}
			$wrapper = $afi ?? $this;
			// @TODO accept newer Rubies if present

			if (!$exists = $wrapper->ruby_installed($version, '>=')) {
				if (!$version = $wrapper->ruby_install(\Opcenter\Versioning::asMinor($version))) {
					error('failed to install Ruby %s', $version);
					return null;
				}
			} else {
				debug("Ruby %(found)s satisfies request %(wanted)s", ['found' => $exists, 'wanted' => $version]);
				// update version with satisficier
				$version = $exists;
			}

			$ret = $wrapper->ruby_do($version, null, 'gem install --no-document -E passenger');
			if (!$ret['success']) {
				error('failed to install Passenger gem: %s', $ret['stderr'] ?? 'UNKNOWN ERROR');
				return null;
			}
			$home = $this->user_get_home($user);
			$stat = $this->file_stat($home);
			if (!$stat || !$this->file_chmod($home, decoct($stat['permissions']) | 0001)) {
				error("failed to query user home directory `%s' for user `%s'", $home, $user);
				return null;
			}

			return $version;
		}

		/**
		 * Get installed version
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return string version number
		 */
		public function get_version(string $hostname, string $path = ''): ?string
		{
			if (!$this->valid($hostname, $path)) {
				return null;
			}
			$approot = $this->getAppRoot($hostname, $path);
			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($approot);
			$ret = $wrapper->ruby_do(null, $approot,
				'ruby -e \'require "./%(path)s" ; puts Discourse::VERSION::STRING;\'',
				['path' => 'lib/version.rb']
			);

			return $ret['success'] ? trim($ret['output']) : null;
		}

		/**
		 * Location is a valid Discourse install
		 *
		 * @param string $hostname or $docroot
		 * @param string $path
		 * @return bool
		 */
		public function valid(string $hostname, string $path = ''): bool
		{
			if (0 === strncmp($hostname, '/', 1)) {
				if (!($path = realpath($this->domain_fs_path($hostname)))) {
					return false;
				}
				$approot = \dirname($path);
			} else {
				$approot = $this->getAppRoot($hostname, $path);
				if (!$approot) {
					return false;
				}
				$approot = $this->domain_fs_path($approot);
			}

			return file_exists($approot . '/lib/discourse.rb');
		}

		public function set_configuration(string $hostname, string $path, array $params = [])
		{
			if (!IS_CLI) {
				return $this->query('discourse_set_configuration', $hostname, $path, $params);
			}
			$config = $this->getAppRoot($hostname, $path) . '/config/discourse.conf';
			$stat = $this->file_stat($config);
			if ($stat && !$stat['can_write']) {
				return error("Path %(path)s unreadable", ['path' => $config]);
			}

			$ini = \Opcenter\Map::load($this->domain_fs_path($config), 'wd', 'inifile')->section(null);
			clearstatcache(true, $this->domain_fs_path($config));
			if (!str_starts_with(realpath($this->domain_fs_path($config)), $this->domain_fs_path('/'))) {
				$ini->close();
				fatal("Unsafe path");
			}

			foreach ($params as $k => $v) {
				$ini[$k] = $v;
			}

			return $ini->save();
		}

		/**
		 * Apply Discourse patches
		 *
		 * @param apnscpFunctionInterceptor $wrapper
		 * @param string                    $approot
		 * @param string                    $version
		 * @throws ReflectionException
		 */
		private function applyPatches(\apnscpFunctionInterceptor $wrapper, string $approot, string $version): void
		{
			if (version_compare('2.5.0', $version, '>')) {
				return;
			}

			$patch = '/0001-Rack-Lint-InputWrapper-lacks-size-method.patch';
			if (version_compare('3.0.0', $version, '<=')) {
				$patch = '/0001-Rack-Lint-InputWrapper-lacks-size-method-3.0.patch';
			} else if (version_compare('2.8.0', $version, '<=')) {
				$patch = '/0001-Rack-Lint-InputWrapper-lacks-size-method-2.8.patch';
			}
			$path = PathManager::storehouse('discourse') . $patch;
			$wrapper->file_put_file_contents($approot . '/0001.patch', file_get_contents($path));
			$ret = $wrapper->pman_run('cd %s && (git apply 0001.patch ; rm -f 0001.patch)', [$approot]);

			if (!$ret['success']) {
				warn("Failed to apply Rack input patch: %s", $ret['stderr']);
			}
		}

		/**
		 * Migrate Discourse database
		 *
		 * @param string $approot
		 * @param string $appenv optional app environment to source DB config
		 * @return bool
		 */
		private function migrate(string $approot, string $appenv = 'production'): bool
		{
			return $this->rake($approot, 'db:migrate', ['RAILS_ENV' => $appenv]);
		}

		private function rake(string $approot, string $task, array $env): bool
		{
			// https://github.com/nodejs/node/issues/25933
			// as is soft, which allows raising to unlimited

			// note: can fail if .bashrc lacks /etc/bashrc source
			$ret = $this->_exec(
				$approot,
				"ulimit -v unlimited ; nvm exec /bin/bash -ic 'rbenv exec bundle exec rake -j" . min(4, (int)NPROC + 1) . " $task'",
				[
					[],
					$env
				],
			);

			return $ret['success'] ?: error("failed Rake task `%s': %s", $task,
				coalesce($ret['stderr'], $ret['stdout']));
		}

		private function _exec(?string $path, $cmd, array $args = array())
		{
			// client may override tz, propagate to bin
			if (!is_array($args)) {
				$args = func_get_args();
				array_shift($args);
			}
			// PHP has no recursive union. array_merge() with numeric keys appends
			$baseArgs = [
				0 => [],
				1 => ['RAILS_ENV' => 'production'],
				2 => []
			];
			$args = array_key_map(static function ($k, $v) use ($args) {
				return ($args[$k] ?? []) + $v;
			}, $baseArgs);

			$user = $this->username;
			if ($path) {
				$cmd = 'cd %(path)s && /bin/bash -ic -- ' . escapeshellarg($cmd);
				$args[0]['path'] = $path;
				$user = $this->file_stat($path)['owner'] ?? $this->username;
			}
			$args[2]['user'] = $user;
			$ret = $this->pman_run($cmd, ...$args);
			if (!strncmp(coalesce($ret['stderr'], $ret['stdout']), 'Error:', strlen('Error:'))) {
				// move stdout to stderr on error for consistency
				$ret['success'] = false;
				if (!$ret['stderr']) {
					$ret['stderr'] = $ret['stdout'];
				}

			}

			return $ret;
		}

		/**
		 * Launch Sidekiq process
		 *
		 * @param string $approot
		 * @param string $mode
		 * @return bool
		 */
		protected function launchSidekiq(string $approot, string $mode = 'production'): bool
		{
			if ($this->sidekiqRunning($approot)) {
				return true;
			}
			$job = [
				'@reboot',
				null,
				null,
				null,
				null,
				'/bin/bash -ic ' .
				escapeshellarg($this->getSidekiqJob($approot, 'production'))
			];
			if (!$this->crontab_exists(...$job)) {
				$this->crontab_add_job(...$job);
			}
			$ret = $this->_exec(
				$approot,
				$this->getSidekiqCommand($approot),
				[
					[
						'approot' => $approot
					],
					[
						'RAILS_ENV' => $mode
					]
				]
			);

			return $ret['success'] ?: error('Failed to launch Sidekiq, check log/sidekiq.log');
		}

		protected function sidekiqRunning(string $approot): ?int
		{
			$pidfile = $approot . '/tmp/sidekiq.pid';
			if (!$this->file_exists($pidfile)) {
				return null;
			}

			$pid = (int)$this->file_get_file_contents($pidfile);

			return \Opcenter\Process::pidMatches($pid, 'ruby') ? $pid : null;
		}

		/**
		 * Get Sidekiq cronjob
		 *
		 * @param string $approot
		 * @param string $env
		 * @return string
		 */
		private function getSidekiqJob(string $approot, $env = 'production')
		{
			return 'cd ' . $approot . ' && env RAILS_ENV=production ' . $this->getSidekiqCommand($approot);
		}

		/**
		 * Get Sidekiq command
		 *
		 * @param string $approot
		 * @return string
		 */
		private function getSidekiqCommand(string $approot)
		{
			return 'bundle exec sidekiq -L log/sidekiq.log -P tmp/sidekiq.pid -q critical -q low -q default -d -c5';
		}

		/**
		 * Compile assets
		 *
		 * @param string $hostname
		 * @param string $path
		 * @param string $appenv
		 *
		 * @return bool
		 */
		private function assetsCompile(string $hostname, string $path = '', string $appenv = 'production'): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($approot);

			$discourseVersion = $this->get_version($hostname, $path);
			if (null === $discourseVersion) {
				return error("Failed to discover Discourse version in `%s'/`%s'", $hostname, $path);
			}
			$nodeVersion = $this->validateNode($discourseVersion, $wrapper);
			$wrapper->node_make_default($nodeVersion, $approot);

			// update deps
			$packages = ['yarn'];
			if (version_compare($discourseVersion, '2.6', '>=')) {
				$packages = array_merge($packages, ['terser', 'uglify-js']);
			} else {
				$packages = array_merge($packages, ['uglify-js@2']);
			}
			$ret = $wrapper->node_do($nodeVersion, null, 'npm install --no-save -g ' . implode(' ', $packages));
			if (!$ret['success']) {
				return error('Failed to install preliminary packages: %s', $ret['error']);
			}

			$ret = $this->_exec($approot, 'nvm exec ' . $nodeVersion . ' yarn install');

			if (!$ret['success']) {
				return error('Failed to install packages: %s', $ret['error']);
			}
			$this->fixupMaxMind($wrapper, $approot);
			$env = [
				'RAILS_ENV' => $appenv,
				'NODE_VERSION' => $nodeVersion
			];
			return $this->rake($approot, 'assets:clean', $env) && $this->rake($approot, 'assets:precompile', $env);
		}

		/**
		 * Verify specific Node major installed
		 *
		 * @param string                    $version Discourse version
		 * @param apnscpFunctionInterceptor $wrapper
		 * @return string required Node version
		 */
		private function validateNode(string $version, \apnscpFunctionInterceptor $wrapper): string
		{
			$nodeVersion = \Opcenter\Versioning::satisfy($version, self::NODE_VERSIONS);
			debug("Validating Node %s installed", $nodeVersion);
			if (!$wrapper->node_installed($nodeVersion)) {
				$wrapper->node_install($nodeVersion);
			}

			return $nodeVersion;
		}

		/**
		 * Replace MaxMind configuration
		 *
		 * CCPA places MaxMind behind a portal. Only available in master
		 *
		 * @param apnscpFunctionInterceptor $wrapper
		 * @param string                    $approot
		 * @return bool
		 */
		private function fixupMaxMind(apnscpFunctionInterceptor $wrapper, string $approot): bool
		{
			$path = "{$approot}/lib/discourse_ip_info.rb";
			$template = file_get_contents(resource_path('storehouse/discourse/discourse_ip_info.rb'));
			return $wrapper->file_put_file_contents($path, $template);
		}

		public function build()
		{
			if (!is_debug()) {
				return true;
			}
			$approot = $this->getAppRoot($this->domain, '');
			$docroot = $this->getDocumentRoot($this->domain, '');
			$context = null;

			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($docroot, $context);
			$passenger = Passenger::instantiateContexted($context, [$approot, 'ruby']);
			$passenger->createLayout();
			$passenger->setEngine('standalone');
			$command = $passenger->getExecutableConfiguration();
			//
			echo $command, "\n";
			dd($passenger->getExecutable(), $passenger->getDirectives());


		}

		public function restart(string $hostname, string $path = ''): bool
		{
			if (!$approot = $this->getAppRoot($hostname, $path)) {
				return false;
			}
			$user = $this->getDocrootUser($approot);
			return Passenger::instantiateContexted(\Auth::context($user, $this->site),
				[$approot, 'ruby'])->restart();
		}

		/**
		 * Install and activate plugin
		 *
		 * @param string $hostname domain or subdomain of wp install
		 * @param string $path     optional path component of wp install
		 * @param string $plugin   plugin name
		 * @param string $version  optional plugin version
		 * @return bool
		 */
		public function install_plugin(
			string $hostname,
			string $path,
			string $plugin,
			string $version = 'stable'
		): bool {
			return error('not supported');
		}

		/**
		 * Get configuration from a webapp
		 *
		 * @param        $hostname
		 * @param string $path
		 * @param string $delete remove all files under docroot
		 * @return bool
		 */
		public function uninstall(string $hostname, string $path = '', string $delete = 'all'): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			// @xxx f'ugly
			$version = (string)$this->get_version($hostname, $path);
			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($approot);
			if ($wrapper !== $this->getApnscpFunctionInterceptor()) {
				$wrapper->discourse_uninstall($hostname, $path, 'proc');
			} else if ($delete !== 'proc') {
				$this->getApnscpFunctionInterceptor()->discourse_uninstall($hostname, $path, 'proc');
			}
			if ($delete === 'proc') {
				$this->kill($hostname, $path);
				// will fail if run as Apache, ignore
				if (version_compare($version, '2.4.0', '<')) {
					$this->pman_run('cd %(approot)s && /bin/bash -ic %(cmd)s',
						['approot' => $approot, 'cmd' => 'rbenv exec passenger stop']);
				}

				if ($this->redis_exists($hostname)) {
					$this->redis_delete($hostname);
				}

				$this->killSidekiq($approot);
				foreach ($this->crontab_filter_by_command($approot) as $job) {
					$this->crontab_delete_job(
						$job['minute'],
						$job['hour'],
						$job['day_of_month'],
						$job['month'],
						$job['day_of_week'],
						$job['cmd']
					);
				}

				return true;
			}
			$this->deleteMailUser($hostname, $path);

			return parent::uninstall($hostname, $path, $delete);
		}

		protected function killSidekiq(string $approot): bool
		{
			if (null === ($pid = $this->sidekiqRunning($approot))) {
				return false;
			}

			return $this->pman_kill($pid);
		}

		/**
		 * Check if version is latest or get latest version
		 *
		 * @param null|string $version
		 * @param string|null $branchcomp
		 * @return bool
		 */
		public function is_current(string $version = null, string $branchcomp = null)
		{
			return parent::is_current($version, $branchcomp);
		}

		/**
		 * Change Discourse admin credentials
		 *
		 * Common fields include: password, email, username, name
		 *
		 * @param string $hostname
		 * @param string $path
		 * @param array  $fields
		 * @return bool
		 */
		public function change_admin(string $hostname, string $path, array $fields): bool
		{
			if (/*!is_debug() &&*/ !IS_CLI) {
				return $this->query('discourse_change_admin', $hostname, $path, $fields);
			}

			$docroot = $this->getAppRoot($hostname, $path);
			if (!$docroot) {
				return warn('failed to change administrator information');
			}

			$admin = $this->get_admin($hostname, $path);

			if (!$admin) {
				return error('cannot determine admin of Discourse install');
			}

			if (isset($fields['password'])) {
				if (!\Opcenter\Auth\Password::strong($fields['password'])) {
					return false;
				}
				$config = Opcenter\Map::read($this->domain_fs_path($docroot . '/config/application.rb'),
					'inifile')->section(null)->quoted(true);
				$itr = (int)($config['config.pbkdf2_iterations'] ?? 64000);
				$algo = $config['config.pbkdf2_algorithm'] ?? 'sha256';
				$fields['salt'] = bin2hex(random_bytes(16));
				$fields['password_hash'] = hash_pbkdf2($algo, $fields['password'], $fields['salt'], $itr);
			}

			if (isset($fields['username'])) {
				$fields['username_lower'] = strtolower($fields['username']);
			}
			if (isset($fields['name'])) {
				$fields['name'] = $fields['name'];
			}

			if (!$db = $this->connectDB($hostname, $path)) {
				return false;
			}

			if (!empty($fields['email'])) {
				if (!preg_match(Regex::EMAIL, $fields['email'])) {
					return error("Invalid email address `%s'", $fields['email']);
				}
				$db->query('UPDATE user_emails SET email = ' . $db->quote($fields['email']) . " WHERE user_id = 1 AND \"primary\" = 't'");
			}
			$q = 'UPDATE users SET id = id';
			foreach (['password_hash', 'salt', 'username', 'username_lower', 'name'] as $field) {
				if (!isset($fields[$field])) {
					continue;
				}
				$q .= ", {$field} = '" . $db->quote($fields[$field]) . "'";
			}
			$q .= ' WHERE id = 1';
			if (!$db->exec($q)) {
				return error("Failed to change admin user `%s'", $admin);
			}
			if (isset($fields['email'])) {
				info('user login changed to %s', $fields['email']);
			}
			if (isset($fields['password'])) {
				info("user `%s' password changed", $fields['email'] ?? $admin);
			}

			return true;
		}

		/**
		 * Get the primary admin for a WP instance
		 *
		 * @param string      $hostname
		 * @param null|string $path
		 * @return string admin or false on failure
		 */
		public function get_admin(string $hostname, string $path = ''): ?string
		{
			if (!$pgsql = $this->connectDB($hostname, $path)) {
				return null;
			}

			$rs = $pgsql->query('SELECT username FROM users WHERE id = 1');
			if (!$rs || $rs->rowCount() < 1) {
				return null;
			}

			return $rs->fetchObject()->username;
		}

		/**
		 * Update core, plugins, and themes atomically
		 *
		 * @param string $hostname subdomain or domain
		 * @param string $path     optional path under hostname
		 * @param string $version
		 * @return bool
		 */
		public function update_all(string $hostname, string $path = '', string $version = null): bool
		{
			return $this->update($hostname, $path, $version) || error('failed to update all components');
		}

		/**
		 * Update Discourse to latest version
		 *
		 * @param string $hostname domain or subdomain under which WP is installed
		 * @param string $path     optional subdirectory
		 * @param string $version
		 * @return bool
		 */
		public function update(string $hostname, string $path = '', string $version = null): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			if (!$approot) {
				return error('update failed');
			}

			$oldVersion = $this->get_version($hostname, $path);
			if (!$version) {
				$version = \Opcenter\Versioning::nextVersion($this->get_versions(),
					$oldVersion);
			} else if (!\Opcenter\Versioning::valid($version)) {
				return error('invalid version number, %s', $version);
			}

			if (!$this->git_valid($approot)) {
				parent::setInfo($this->getDocumentRoot($hostname, $path), [
					'failed' => true
				]);

				return error('Cannot upgrade Discourse - not a valid git repository');
			}

			if (version_compare($oldVersion, '3.0', '<') && version_compare($version, '3.0', '>=')) {
				$this->pgsql_add_extension($this->db_config($hostname, $path)['db'], 'unaccent');
			}
			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($approot);
			$minimum = null;
			if (!$this->versionCheck($approot, $version, $minimum)) {
				parent::setInfo($this->getDocumentRoot($hostname, $path), [
					'failed' => true
				]);

				return error("Configured Ruby version `%(found)s' does not meet minimum requirement `%(min)s' for Discourse v%(discourse_ver)s", [
					'found' => $wrapper->ruby_version_from_path($approot),
					'min' => $minimum,
					'discourse_ver' => $version
				]);
			}

			$wrapper->git_fetch($approot);
			$wrapper->git_fetch($approot, ['tags' => null, 'force' => null]);
			if ($wrapper->file_exists($approot . '/lib/discourse_ip_info.rb')) {
				$wrapper->git_checkout($approot, null, ['lib/discourse_ip_info.rb']);
			}

			$ret = $wrapper->git_checkout($approot, "v{$version}");
			$this->applyPatches($wrapper, $approot, $version);

			// uri updates to 0.11.0
			if (version_compare($version, '2.8.10', '>=') && version_compare($oldVersion, '2.8.10', '<')) {
				$wrapper->ruby_do(null, $approot, 'gem update --system --no-doc');
			}

			if ($ret) {
				// use default Ruby wrapper
				$wrapper->ruby_do('', $approot, 'bundle install -j' . min(4, (int)NPROC + 1));
				$this->migrate($approot);
				$this->update_plugins($hostname, $path);
				if (!$this->assetsCompile($hostname, $path)) {
					warn('Failed to compile assets');
				}
			}

			if (!\Opcenter\Versioning::compare($version, $newver = $this->get_version($hostname, $path))) {
				report("Upgrade failed, reported version `%s' is not requested version `%s'", $newver, $version);
			}
			parent::setInfo($this->getDocumentRoot($hostname, $path), [
				'version' => $version,
				'failed'  => !$ret
			]);

			if (!$ret) {
				return error('failed to update Discourse');
			}

			if (version_compare($version, '3.0.0', '>=')) {
				$this->createMailUser($hostname, $path);
			}

			return $this->restart($hostname, $path);
		}

		/**
		 * Get all available Discourse versions
		 *
		 * @return array
		 */
		public function get_versions(): array
		{
			$versions = $this->_getVersions();

			return array_column($versions, 'version');
		}

		/**
		 * Get all current major versions
		 *
		 * @return array
		 */
		private function _getVersions(): array
		{
			$key = 'discourse.versions';
			$cache = Cache_Super_Global::spawn();
			if (false !== ($ver = $cache->get($key))) {
				return (array)$ver;
			}
			$versions = (new Github)->setMode('tags')->fetch('discourse/discourse');
			$cache->set($key, $versions, 43200);

			return $versions;
		}

		/**
		 * Ruby interpreter meets minimum version requirement
		 *
		 * @param string $approot          app root
		 * @param string $discourseVersion requested Discourse version
		 * @param null   $minVersion
		 * @return bool
		 */
		private function versionCheck(string $approot, string $discourseVersion, &$minVersion = null): bool
		{
			$wrapper = $this->getApnscpFunctionInterceptorFromDocroot($approot);
			$version = $wrapper->ruby_version_from_path($approot);

			$minVersion = \Opcenter\Versioning::satisfy($discourseVersion, self::MINIMUM_INTERPRETERS);

			if (version_compare($version, $minVersion, '>=')) {
				return true;
			}

			// can we upgrade?
			foreach ($wrapper->ruby_list() as $version) {
				if (version_compare($version, $minVersion, '>=')) {
					info("Changed default Ruby interpreter to `%(version)s' on `%(path)s'", [
						'version' => $version, 'path' => $approot
					]);
					$wrapper->ruby_make_default($version, $approot);
					return true;
				}
			}

			return false;
		}

		/**
		 * Update plugins
		 *
		 * @param string $hostname domain or subdomain
		 * @param string $path     optional path within host
		 * @param array  $plugins
		 * @return bool
		 */
		public function update_plugins(string $hostname, string $path = '', array $plugins = array()): bool
		{
			if (!$approot = $this->getAppRoot($hostname, $path)) {
				return false;
			}
			return $this->rake($approot, 'plugin:pull_compatible_all', ['LOAD_PLUGINS' => 0, 'RAILS_ENV' => 'production']);
		}

		/**
		 * Update Laravel themes
		 *
		 * @param string $hostname subdomain or domain
		 * @param string $path     optional path under hostname
		 * @param array  $themes
		 * @return bool
		 */
		public function update_themes(string $hostname, string $path = '', array $themes = array()): bool
		{
			return error('not implemented');
		}

		/**
		 * @inheritDoc
		 */
		public function has_fortification(string $hostname, string $path = '', string $mode = null): bool
		{
			return false;
		}

		/**
		 * @inheritDoc
		 */
		public function fortification_modes(string $hostname, string $path = ''): array
		{
			return parent::fortification_modes($hostname, $path);
		}

		/**
		 * Restrict write-access by the app
		 *
		 * @param string $hostname
		 * @param string $path
		 * @param string $mode
		 * @param array  $args
		 * @return bool
		 */
		public function fortify(string $hostname, string $path = '', string $mode = 'max', $args = []): bool
		{
			return error('not implemented');
		}

		/**
		 * Relax permissions to allow write-access
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return bool
		 * @internal param string $mode
		 */
		public function unfortify(string $hostname, string $path = ''): bool
		{
			return error('not implemented');
		}

		/**
		 * Laravel housekeeping
		 *
		 * @return bool
		 */
		public function _housekeeping()
		{
			// nothing to do as Symfony is managed separately by
			// a the PHP module
			return true;
		}

		public function theme_status(string $hostname, string $path = '', string $theme = null)
		{
			return parent::theme_status($hostname, $path, $theme);
		}

		public function install_theme(string $hostname, string $path, string $theme, string $version = null): bool
		{
			return parent::install_theme($hostname, $path, $theme, $version);
		}

		/**
		 * Fake admin to change its credentials
		 *
		 * @param string $hostname
		 * @param string $path
		 * @return bool
		 * @throws PostgreSQLError
		 */
		private function createAdmin(string $hostname, string $path): bool
		{
			if (!$approot = $this->getAppRoot($hostname, $path)) {
				return false;
			}
			if (!$db = $this->connectDB($hostname, $path)) {
				return error('Failed to connect to Discourse database');
			}
			if ($db->query('SELECT FROM users WHERE id = 1')->rowCount() > 0) {
				return warn('Admin user (id = 1) already present, not creating');
			}
			$hash = hash('sha256', (string)random_int(PHP_INT_MIN, PHP_INT_MAX));
			$sth = $db->prepare('INSERT INTO users (id, admin, created_at, updated_at, trust_level, username, username_lower, password_hash, salt, ip_address) VALUES(1, \'t\', NOW(), NOW(), 1, :user, LOWER(:user), :hash, :salt, :ip);');
			$r1 = $sth->execute([
				'user' => $this->username,
				'hash' => hash_hmac('sha256', (string)random_int(PHP_INT_MIN, PHP_INT_MAX), $hash),
				'salt' => substr($hash, 0, 32),
				'ip'   => \Auth::client_ip()
			]);
			$sth = $db->prepare('INSERT INTO user_emails (id, user_id, created_at, updated_at, email, "primary") VALUES(1, 1, NOW(), NOW(), :email, \'t\')');

			return $r1 && $sth->execute(['email' => $this->common_get_email()]);
		}

		private function connectDB(string $hostname, string $path): ?PDO
		{
			$dbconfig = $this->db_config($hostname, $path);
			if (empty($dbconfig['user'])) {
				return null;
			}

			try {
				return \Module\Support\Webapps::connectorFromCredentials($dbconfig);
			} catch (PDOException $e) {
				return null;
			}
		}

		/**
		 * Get database configuration for Discourse
		 *
		 * @param string $hostname domain or subdomain of wp blog
		 * @param string $path     optional path
		 * @return bool|array
		 */
		public function db_config(string $hostname, string $path = '')
		{
			if (!IS_CLI) {
				return $this->query('discourse_db_config', $hostname, $path);
			}

			$approot = $this->getAppRoot($hostname, $path);

			if (!$approot) {
				error('failed to determine Discourse app root - ' . $approot);

				return [];
			}
			$config = $approot . '/config/discourse.conf';

			if (!file_exists($this->domain_fs_path($config))) {
				error('failed to locate Discourse config in ' . $approot);

				return [];
			}
			$ini = \Opcenter\Map::load($this->domain_fs_path($config), 'r', 'inifile')->section(null);

			return [
				'db'       => $ini['db_name'],
				'host'     => $ini['db_host'],
				'user'     => $ini['db_username'],
				'password' => $ini['db_password'],
				'prefix'   => '',
				'type'     => 'pgsql'
			];
		}
	}